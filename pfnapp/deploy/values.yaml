# Default values for deploy chart
# This is a YAML-formatted file.

# Application configuration
app:
  name: "myapp"
  version: "latest"

# Deployment type: "deployment" or "statefulset"
deploymentType: "deployment"

# Replica count
replicaCount: 1

# Image configuration
image:
  repository: "nginx"
  tag: "latest"
  pullPolicy: IfNotPresent

# Image pull secrets
imagePullSecrets: []

# Service account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod annotations
podAnnotations: {}

# Pod security context
podSecurityContext: {}

# Container security context
securityContext: {}

# Resource limits and requests
resources: {}

# Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80

# Node selector
nodeSelector: {}

# Tolerations for taints
tolerations: []

# Affinity rules
affinity: {}

# Service configuration
service:
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: 80
  annotations: {}

# Single Ingress configuration (legacy support)
ingress:
  enabled: false
  className: "haproxy"
  annotations:
    haproxy.org/load-balance: "roundrobin"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

# Multiple Ingresses configuration (advanced)
# Use this for multiple ingress classes, different annotations per domain, etc.
ingresses: {}
  # Example configuration:
  # public:
  #   enabled: true
  #   className: "haproxy"
  #   annotations:
  #     haproxy.org/load-balance: "roundrobin"
  #     haproxy.org/check: "true"
  #   hosts:
  #     - host: myapp.example.com
  #       paths:
  #         - path: /
  #           pathType: Prefix
  #   tls:
  #     - secretName: myapp-tls
  #       hosts:
  #         - myapp.example.com
  # 
  # admin:
  #   enabled: true
  #   className: "nginx"
  #   annotations:
  #     nginx.ingress.kubernetes.io/auth-type: basic
  #     nginx.ingress.kubernetes.io/auth-secret: admin-auth
  #   hosts:
  #     - host: admin.myapp.example.com
  #       paths:
  #         - path: /admin
  #           pathType: Prefix
  #   tls:
  #     - secretName: admin-tls
  #       hosts:
  #         - admin.myapp.example.com

# Domain-based Ingress configuration (generates ingress names from domains)
# Each domain gets its own ingress resource named after the domain
ingressDomains: []
  # Example configuration:
  # - enabled: true
  #   host: "myapp.example.com"
  #   className: "haproxy"
  #   tls: true
  #   tlsSecret: "myapp-example-com-tls"  # Optional, auto-generated if not specified
  #   annotations:
  #     haproxy.org/load-balance: "roundrobin"
  #     haproxy.org/check: "true"
  #   paths:
  #     - path: /
  #       pathType: Prefix
  # - enabled: true
  #   host: "admin.myapp.example.com"
  #   className: "nginx"
  #   tls: true
  #   annotations:
  #     nginx.ingress.kubernetes.io/auth-type: basic
  #     nginx.ingress.kubernetes.io/auth-secret: admin-auth
  #   paths:
  #     - path: /admin
  #       pathType: Prefix

# Simplified Ingress configuration with Let's Encrypt and External DNS automation
# Just provide domain, cert-manager issuer, and external DNS config - everything else is automated
simpleIngress: []
  # Example configuration:
  # - enabled: true
  #   domain: "metacard-sso-dev.pfnapp.dev"  # Just the domain - host and TLS secret auto-generated
  #   className: "haproxy"
  #   tls: true  # Enable TLS - secret name auto-generated as "metacard-sso-dev-pfnapp-dev-tls"
  #   # tlsSecretName: "custom-tls-secret"  # Optional: override auto-generated TLS secret name
  #   certManager:
  #     enabled: true
  #     issuer: "pfnapp-dev"  # cert-manager cluster issuer name
  #   externalDns:
  #     enabled: true
  #     target: "cname-sg.pfnapp.com"  # external-dns target
  #     cloudflareProxied: false  # Optional: set cloudflare proxy status
  #   # paths:  # Optional: defaults to [{"path": "/", "pathType": "Prefix"}]
  #   #   - path: /
  #   #     pathType: Prefix
  #   # annotations:  # Optional: additional custom annotations
  #   #   custom.annotation/key: "value"

# Environment variables from ConfigMap (creates ConfigMap managed by Helm)
configMap:
  enabled: false
  data: {}

# Environment variables from Secret (creates Secret managed by Helm)
secret:
  enabled: false
  data: {}

# Environment variables (supports both direct values and references to external ConfigMaps/Secrets)
env: []
  # Examples:
  # - name: "ENVIRONMENT"           # Direct value
  #   value: "production"
  # - name: "DATABASE_URL"          # From external ConfigMap
  #   valueFrom:
  #     configMapKeyRef:
  #       name: "database-config"
  #       key: "url"
  #       optional: false           # Optional: set to true if the key might not exist
  # - name: "API_KEY"               # From external Secret
  #   valueFrom:
  #     secretKeyRef:
  #       name: "api-secrets"
  #       key: "key"
  #       optional: false
  # - name: "POD_NAME"              # From field reference
  #   valueFrom:
  #     fieldRef:
  #       fieldPath: "metadata.name"
  # - name: "CPU_REQUEST"           # From resource field reference
  #   valueFrom:
  #     resourceFieldRef:
  #       resource: "requests.cpu"

# Environment variables from external ConfigMaps/Secrets (loads all keys as env vars)
envFrom: []
  # Examples:
  # - configMapRef:                 # Load all keys from external ConfigMap
  #     name: "app-config"
  #     optional: false             # Optional: set to true if ConfigMap might not exist
  # - secretRef:                    # Load all keys from external Secret
  #     name: "app-secrets"
  #     optional: false

# Logging configuration
logging:
  enabled: false
  # When enabled, appends "-service" to deployment name and adds log taints

# StatefulSet specific configuration
statefulset:
  serviceName: ""
  volumeClaimTemplates: []

# Container ports
containerPorts:
  - containerPort: 80
    name: http

# Liveness and readiness probes
livenessProbe: {}
readinessProbe: {}

# Volume mounts
volumeMounts: []

# Volumes
volumes: []